---
title: "CLI"
---

- `qcpu [-o output] file.s | file.o | file...`: performs preprocessing,
  assembling and linking of the designated files. A file may be an assembly,
  object or executable file.
- `qcpu -c [-o output.o] file.s...`: performs only preprocessing and
  assembling.
- `qcpu -p [-o output.s] file.s...`: performs only preprocessing.

An optimiser option may be set to cut out dead text paths, `-O1` (first level
optimisation).

::: {.note}
TODO: define devices and their register ABI for the device id
:::

### Linker

- `qcpul [-o output] [kernel.o] file.o...`: the jump to main of the linker,
  called from the linking step of `qcpu` and `qcpuc`.

QCPU CLI's linker alters instructions depending on the address (e.g. relative
vs. absolute jumps), and may insert additional data for that, aside from kernel
extensions. A userland application must therefore be linked with the kernel
object file.

### Compiler

Coming soonâ„¢

- `qcpuc [-o output] file.c...`: performs compilation and all of the above.
- `qcpuc -c [-o output.o] file.c...`: performs compilation and assembling
  without linking.
- `qcpuc -p [-o output.c] file.c...`: only performs the language preprocessor.

## Emulation

Each executable file generated by `qcpul` starts with a Shebang:

```{.bash}
#!/usr/bin/env qcpuv
```

It calls the following synopsis:

```
qcpuv [-s hertz] [-b batch] executable
```

Emulates the executable through instruction-level virtualisation. If
`executable` includes a boot `entrypoint`, it gets loaded into fixed kernel
space in kernel mode, otherwise into userland in user mode. A basic memory map
is then done to map globals, locals and the stack.

- `-s hertz` is default 0 (no wait),
- `-b batch` is default 1 (one cycle per update).

## Makefile

In an operating system environment, it's useful to set up a Makefile to perform
all the commands in steps.

```{.makefile}
SOURCES = boot/main.s kernel/main.s bin/sh.s
OBJECTS = ${SOURCES:.s=.o}

.s.o:
    qcpu -c $<

all: ${OBJECTS}
    qcpu -o output ${OBJECTS}
```
